import { LabelingContext } from "../../../../ai/context/extractLabelingContext";

export function buildControlHasAssociatedLabelPrompt(c: LabelingContext): string {
  return [
    "You are fixing labeling accessibility for a form control in JSX.",
    "",
    "Goal: Ensure the control has an accessible name.",
    "",
    "Preferred options (in order):",
    "1. **(Best)** If the control has an 'id', wrap it and a new <label> in a <div> or <React.Fragment>. The label's htmlFor attribute must match the control's id.",
    "Example: <div><label htmlFor=\"email\">Email</label><input id=\"email\" /></div>", 
    "2. If wrapping is difficult, use aria-labelledby to reference EXISTING visible text.",
    "3. If no visible text is available, add a concise aria-label as a last resort.",
    "",
    "Rules:",
    "- Keep the diff minimal; do NOT refactor unrelated code.",
    "- If an adequate visible label already exists, do NOT add aria-label.",
    "- Choose a short neutral label if nothing is available (e.g., 'Search', 'Email').",
    "- Avoid duplicate naming mechanisms for the same control.",
    "",
    "Output format:",
    '- Return ONLY a JSON object: { "fixedCode": "<JSX...>" }',
    "- If you cannot produce JSON, return ONLY the patched JSX code block.",
    "",
    `File path: ${c.filePath}`,
    `Line: ${c.line}`,
    "",
    "Original snippet:",
    "```jsx",
    c.snippet,
    "```",
    "",
    "Context hints:",
    `- associatedLabelText: ${c.associatedLabelText ?? ""}`,
    `- neighborText: ${c.neighborText ?? ""}`,
    `- controlType: ${c.controlType ?? ""}`,
    `- isFormAncestor: ${String(c.isFormAncestor)}`,
  ].join("\n");
}
